#!/usr/bin/env python

"""

Place this `upload.py` in `<irods>/server/bin/cmd` and make sure it is owned and executable by the iRODS user.

iRODS api hooks, configured on core.re.

`<id>` is the policy id generated by the DPM and stored in the policy.xml and policy .replicate files.
`*centerId`, identifier for the datacenter running the DPM client as defined by the DPM server
`*communityId`, community identifier on behalf of which the DPM client is running as defined by the DPM server
`*apiEndpoint`, DPM server HTTP API endpoint, accepting policy state updates

- Trigger on creation of `<id>.replicate` file.
State change: QUEUED --> RUNNING

    acPostProcForPut {
        ON($objPath like "\*.replicate") {
            *centerId = ""
            *communityId = ""
            *apiEndpoint = "https://dpm-eudat.norstore.uio.no/cgi-bin/updatepolicy.py"
            msiExecCmd("upload.py", "-u *apiEndpoint -c *centerId -C *communityId -s *sourceObject -d *destObject", "null", "null", "null", *out);
        }
    }

- Trigger on rename of `<id>.replicate` file to `<id>.replicate.success` or `<id>.replicate.failure`.
Policy state change: RUNNING --> (FINISHED | FAILED)

acPostProcForObjRename(*sourceObject,*destObject) {
        ON($objPath like "\*.replicate\*") {
                *centerId = ""
                *communityId = ""
                *apiEndpoint = "https://dpm-eudat.norstore.uio.no/cgi-bin/updatepolicy.py"
                msiExecCmd("upload.py", "-u *apiEndpoint -c *centerId -C *communityId -s *sourceObject -d *destObject", "null", "null", "null", *out);
        }
}


Data uploads to the server HTTP API endpoint have the following format and will be send as form-www/encoded name,value pairs:

{
    'id': policyId,                 policy uid, extracted from .replicate file
    'state': args.state,            policy state, extracted from .replicate file (RUNNING, FINISHED, FAILED)
    'timestamp': timestamp,         unix timestamp (seconds since EPOCH) when this script was triggered
    'center': args.center,          center id
    'community': args.community     community id
}

"""

__author__ = 'Willem Elbers, MPI-TLA, willem.elbers@mpi.nl'

import argparse
import urllib2
import urllib
import time

def upload(args):
    #Extract the policy id and the policy execution status from the policy name
    segments = args.destination.split('.')
    policyId = segments[0]
    if segments[-1].lower() == 'replicate':
        state = 'RUNNING'
    elif segments[-1].lower() == 'success':
        state = 'FINISHED'
    else:
        state = 'FAILED'
    #Get the current UNIX timestamp
    timestamp = time.time()

    # Upload information
    data = urllib.urlencode({'id': policyId, 'state': state, 'timestamp': timestamp, 'center': args.center, 'community': args.community})
    req = urllib2.Request(url=args.url, data=data)
    content = urllib2.urlopen(req).read()
    #print content

def main():
    argp = argparse.ArgumentParser(description="EUDAT Data Policy Manager data upload script")
    argp.add_argument('-u', '--url', required=True , help='Api endpoint')
    argp.add_argument('-c', '--center', required=True, help='Center id')
    argp.add_argument('-C', '--community', required=True, help='Community id')
    argp.add_argument('-s', '--source', required=False, help='Object before rename')
    argp.add_argument('-d', '--destination', required=False, help='Object after rename')

    args = argp.parse_args()
    upload(args)

if __name__ == '__main__':
    main()
